"""A simple menu class that uses the curses library to display a menu on the terminal."""

import curses


class Menu:
    """A simple menu class that uses the curses library to display a menu on the terminal."""

    def __init__(self, menu_options):
        """Initialize the menu with the given options."""
        # Initialize the library. Returns a WindowObject which represents the whole screen.
        self.window = curses.initscr()
        # Escape sequences generated by some keys (keypad, function keys) will be interpreted by curses.
        self.window.keypad(True)
        curses.cbreak()  # Keys are read one by one. Also safer than curses.raw() because you can still interrupt a running script with hotkeys.
        curses.noecho()  # Prevent getch() keys from being visible when pressed. Echoing of input characters is turned off.
        # Initialize colors.
        curses.start_color()  # Must be called if the programmer wants to use colors.
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
        curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_BLACK)
        self.black = curses.color_pair(1)
        self.white = curses.color_pair(2)
        self.menu_options = menu_options

    def show(self):
        """Write a menu to the screen and return the index of the selected option."""
        selectedIndex = 0
        self.window.clear()
        self.window.addstr("What do you want to do?\n", curses.A_UNDERLINE)

        for index in enumerate(self.menu_options):
            i = index[0]
            # Uncolored line number.
            self.window.addstr(f"{i + 1}. ")
            # Colored menu option.
            self.window.addstr(
                self.menu_options[i] + "\n",
                self.black if i == selectedIndex else self.white,
            )
        c = self.window.getch()

        if c == curses.KEY_UP or c == curses.KEY_LEFT:
            # Loop around backwards.
            selectedIndex = (selectedIndex - 1 + len(self.menu_options)) % len(
                self.menu_options
            )

        elif c == curses.KEY_DOWN or c == curses.KEY_RIGHT:
            # Loop around forwards.
            selectedIndex = (selectedIndex + 1) % len(self.menu_options)

        # If curses.nonl() is called, Enter key = \r else \n.
        elif c == curses.KEY_ENTER or chr(c) in "\r\n":
            # If the last option, exit, is selected.
            if selectedIndex == len(self.menu_options) - 1:
                curses.endwin()  # De-initialize the library, and return terminal to normal status.    <-- Works without this on Windows, however in Linux you can't type in the terminal after exiting without this :P
                return len(self.menu_options) - 1

            self.window.addstr(f"\nYou choose {self.menu_options[selectedIndex]}\n")
            self.window.getch()
            return selectedIndex

        else:
            self.window.addstr(
                f"\nThe pressed key '{chr(c)}' {c} is not associated with a menu function.\n"
            )
            self.window.getch()
